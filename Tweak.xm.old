#import "iSponsorBlock.h"
#import "sponsorTimes.h"

YTWatchController *YTWatchControllerInstance;
MLNerdStatsPlaybackData *MLNerdStatsPlaybackDataInstance;
NSString *currentVideoID = nil;

//create dispatch queue to perform asynchronous tasks in.
dispatch_queue_t queue;
%ctor {
	queue = dispatch_queue_create("com.galacticdev.skipSponsorQueue", NULL);
}

%hook YTWatchController
-(id)initWithWatchFlowController:(id)arg1 parentResponder:(id)arg2 {
	YTWatchControllerInstance = self;
	return %orig;
}
%end

%hook MLHAMPlayer

//This method is called every time the video changes, so that is why I chose it. 
-(void)availableCaptionTracksDidChange:(id)arg1 {
	%orig;
	NSLog(@"availableCaptionTracksDidChange was called");
	dispatch_queue_t otherQueue;
	otherQueue = dispatch_queue_create("com.galacticdev.otherQueue", NULL);
	dispatch_async(otherQueue, ^{
	NSLog(@"currentVideoID is currently = %@", currentVideoID);
		if(currentVideoID == nil) {
			
			[NSThread sleepForTimeInterval:0.5f]; 
			currentVideoID = [MLNerdStatsPlaybackDataInstance videoID];
			NSLog(@"currentVideoID = %@", currentVideoID);
			[%c(sponsorTimes) getSponsorTimes:currentVideoID completionTarget:self completionSelector:@selector(skipFirstSponsor:)];
		}
		[NSThread sleepForTimeInterval:0.5f];
		currentVideoID = [MLNerdStatsPlaybackDataInstance videoID];
			
		
		
	});
	
}
%new
-(void)skipFirstSponsor:(NSDictionary *)data {
	NSLog(@"skipFirstSponsor was called with data %@", data);
	__block NSDictionary *dataCopy = data;
	currentVideoID = nil;
	if([dataCopy objectForKey:@"sponsorTimes"] != nil) {	
		NSString *videoID = [dataCopy objectForKey:@"videoID"];
		if(currentVideoID == videoID) {
			int cnt = [dataCopy count];
			if(cnt > 1) {
				NSArray *firstSponsorship = [dataCopy objectForKey:@"sponsorTimes"][0];
				float videoTime = lroundf([YTWatchControllerInstance activeVideoMediaTime]);

				if(videoTime == lroundf([firstSponsorship[0] floatValue])){
					dispatch_async(queue, ^{
						[self seekToTime:[firstSponsorship[1] floatValue]];
						[NSThread sleepForTimeInterval:0.5f];
						[self skipSecondSponsor:dataCopy];	
						dataCopy = nil;
					});
				}
				else if (videoTime < lroundf([firstSponsorship[0] floatValue])){
					dispatch_async(queue, ^ {
						[NSThread sleepForTimeInterval:0.5f];
						[self skipFirstSponsor:dataCopy];
					});
				}

			}
			if(cnt == 1){
				NSArray *firstSponsorship = [dataCopy objectForKey:@"sponsorTimes"][0];
				float videoTime = lroundf([YTWatchControllerInstance activeVideoMediaTime]);

				if(videoTime == lroundf([firstSponsorship[0] floatValue])){
					dispatch_async(queue, ^ {
						[self seekToTime:[firstSponsorship[1] floatValue]];
						dataCopy = nil;
						currentVideoID = nil;
					});
				}
				else if (videoTime < lroundf([firstSponsorship[0] floatValue])){
					dispatch_async(queue, ^ {
						[NSThread sleepForTimeInterval:0.5f];
						[self skipFirstSponsor:dataCopy];
					});
				}
			
			}
		}

		else{
			dispatch_async(queue, ^ {
				[NSThread sleepForTimeInterval:0.5f];
				currentVideoID = [MLNerdStatsPlaybackDataInstance videoID];
				[%c(sponsorTimes) getSponsorTimes:currentVideoID completionTarget:self completionSelector:@selector(skipFirstSponsor:)];
			});
			
		} 
	
	}

	else {
		dispatch_async(queue, ^ {
			NSLog(@"else thing was called!");
			currentVideoID = nil;
			[self availableCaptionTracksDidChange:nil];
		});
		
	}
}
%new 
-(void)skipSecondSponsor:(NSDictionary *)data {
	__block NSDictionary *dataCopy = data;
	
	if([dataCopy objectForKey:@"sponsorTimes"] != nil) {
		NSString *videoID = [dataCopy objectForKey:@"videoID"];
		if(currentVideoID == videoID) {
			NSArray *secondSponsorship = [dataCopy objectForKey:@"sponsorTimes"][1];
			float videoTime = lroundf([YTWatchControllerInstance activeVideoMediaTime]);

			if(videoTime == lroundf([secondSponsorship[0] floatValue])){
						dispatch_async(queue, ^{
							[self seekToTime:[secondSponsorship[1] floatValue]];
							currentVideoID = nil;
						});
			}
			else if (videoTime < lroundf([secondSponsorship[0] floatValue])){
					dispatch_async(queue, ^{
						[NSThread sleepForTimeInterval:1.0f];
						[self skipSecondSponsor:dataCopy];
					});
				}
		}
		else{
			dispatch_async(queue, ^{
				[NSThread sleepForTimeInterval:0.5f];
				[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(skipSecondSponsor:) object:dataCopy];
				currentVideoID = [MLNerdStatsPlaybackDataInstance videoID];
				[%c(sponsorTimes) getSponsorTimes:currentVideoID completionTarget:self completionSelector:@selector(skipFirstSponsor:)];
			});
			
		}
	}

	else {
		currentVideoID = nil;
	}
	

}
%end

%hook MLNerdStatsPlaybackData
-(id)initWithPlayer:(id)arg1 videoID:(id)arg2 CPN:(id)arg3 {
	MLNerdStatsPlaybackDataInstance = self;
	return %orig;
}
%end




//dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)